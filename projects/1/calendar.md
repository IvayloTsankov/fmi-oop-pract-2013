# Календар

## Работа с дати

Нека да реализираме малка библиотека за работа с дати. Тя има следните класове:

### TimeZone

Обектите на класа отразяват отместване от определен брой часове спрямо часовата зона UTC. Реализирайте:

*   конструктор `TimeZone(name, offset)`. Името на часовата зона се състои от най-много 5 символа;
*   методи `getName` и `getOffset`;
*   оператори `==` и `!=`;
*   оператор `<<` за извеждане в поток — изведете името на часовата зона.

Добавете няколко константни статични члена към класа TimeZone, които да представят предварително дефинирани часови зони (по ваш избор кои). Например трябва с `TimeZone.UTC` да може да се достъпва обекта, представяш UTC часовата зона (с отместване 0), а с `TimeZone.EET` — източноевропейско време (с отместване +2).

### Duration

Обектите на класа `Duration` представят продължителност от определен брой секунди. Той трябва да:

*   може да се конструира по `Duration(seconds, minutes, hours, days)`, `Duration(seconds, minutes, hours)`, `Duration(seconds, minutes)` и `Duration(seconds)` и `Duration()` (продължителност от нула секунди). Продължителността може да бъде и отрицателна. Всеки от параметрите може да бъде произволно голям;
*   има методи `asSeconds`, `asMinutes`, `asHours`, и `asDays`, връщащи продължителността в брой, съответно, секунди, минути, часове и дни закръглено надолу за неотрицателни стойности и нагоре за отрицателни. Например `Duration(3 * 60 * 60 + 4).asHours()` връща 3;
*   има методи `getSecond`, `getMinute` и `getHour` връщащи съответно секундата на текущата минута (между 0 и 59), минутата на текущия час (между 0 и 59), часът да текущия ден (между 0 и 23). Например `Duration(3 * 60 * 60 + 4).getSecond()` дава 4, а `Duration(3 * 60 * 60 + 4).getMinute() — 0;
*   предефинира оператори `+` и `-` за събиране и изваждане на продължителности;
*   предефинира операторите `<`, `<=`, `==`, `!=`, `>`, и `>=`;
*   предефинира оператор `<<` за извеждане в поток в подходящ формат по ваш избор. Например `3 hours and 4 seconds`.

### DateTime

`DateTime` представя дата и час в определена часова зона.

Във всеки един момент за нашата програма има избрана часова зона по подразбиране. Тя трябва да може да се вземе чрез статичния метод `getDefaultTimeZone()` на DateTime и да може да бъде зададена чрез статичния метод `setDefaultTimeZone(timeZone)`. Нека първоначално тя да е UTC.

За `DateTime` реализирайте:

*   следните конструктори:
    -   `DateTime(year, month, day, hour, minute, second, timeZone)`;
    -   `DateTime(year, month, day, timeZone)`;
    -   `DateTime(year, month, day, hour, minute, second)`;
    -   `DateTime(year, month, day)`;
    -   `DateTime()` създаващ обект, съответващ на датата 1-ви януари 1970-та;
    -   Конструкторите, които не приемат часова зона, трябва да използват подразбиращата се;
*   селектори за всяко от `year`, `month`, `day`, `hour`, `minute`, `second` и `timeZone`;
*   метод `toTimeZone(timeZone)` връщащ нов обект с часа, конвертиран в съответната часова зона;
*   оператор `()`, приемащ часова зона, който връща същото като предишния метод;
*   оператори `+` и `-` с втори операнд — `Duration` обект;
*   оператор `-` с втори операнд `DateTime` обект, връщащ разликата между двете дати като продължителност (като тя трябва да е отрицателна, ако първата дата е преди втората);
*   релационните оператори `<`, `<=`, `==`, `!=`, `>`, и `>=`;
*   оператор `<<` за извеждане в поток в подходящ формат по ваш избор;

Всички методи и оператори трябва да могат да работят с часове от произволна часова зона.

Където е подходящо, се възползвайте от възможностите на `Duration` обектите (например за реализирането на релационните оператори).

## Управление на събития

В допълнение ще реализираме и класове, с помощта на които да организираме календар от събития. Те са:

### Event

Обектите на класа представят определено събитие. Събитието трябва да може да се конструира чрез следните конструктори:

*   `Event(name, startDateTime, endDateTime, priority, description)` и
*   `Event(name, startDateTime, duration, priority, description)`,

където `name` и `description` са низове с произволна дължина, а `priority` задава приоритета на събитието — нисък, нормален или висок.

Реализирайте селектори и мутатори за `name`, `startDateTime`, `endDateTime`, `duration`, `priority` и `description`. Събитията ще имат неотрицателна продължителност и крайната им дата няма да бъде преди началната.

### Calendar

Представя съвкупност от събития във времето. Освен това календарът си има и име — низ с произволна дължина. Съвкупността от събития може да реализирате по какъвто начин изберете, единствено изискване е да може да побере произволен брой събития.

Чрез конструктора `Calendar(name)` трябва да може да бъде създаван празен календар със съответното име.

За календара реализирайте още:

*   метод `getName`, връщащ името на календара;
*   оператор `<<` с ляв операнд календар и десен — събитие, добавящ събитието към календара;
*   в зависимост от реализация ви на множеството от събития, реализирайте подходящ интерфейс, който да позволява обхождане на всички събития в календара и тяхното премахване или промяна.

## Демонстрация

Реализирайте програма, демонстрираща използването на горните класове, която да позволява на потребителя да:

*   създава нов календар и добавя събития в него;
*   да задава часова зона, в която да вижда събитията. Тя трябва да може да бъде променяна дори ако вече има въведени събития;
*   бъде изведен списък от всички събития. По желание на потребителя събитията трябва да могат да бъдат филтрирани по приоритет и/или интервал от начален и краен час.
*   записва събитията в текстов файл с определен формат. Аналогично, записаните събития трябва да могат да бъдат филтрирани по горните критерии. Часовете трябва да са в избраната от потребителя часова зона. Текстовият файл трябва да започва с името на календара, след което следват събитията, записани в избран от вас формат. Нека между всеки две събитията да има един празен ред.

## Допълнителни указания

За всички класове:

*   подберете подходящо вътрешно представяне на данните;
*   изберете подходящи типове за аргументите на методите;
*   където е необходимо дефинирайте собствени копиращ конструктор, оператор `=` и деструктор;
*   не забравяйте да декларирате методите, които трябва да бъдат константни, като такива. Ако за някои методи има смисъл да имат както константен така и неконстантен вариант, то реализирайте и двата.

Свободно може да добавяте и допълни класове и методи в допълнение на гореописаните, ако те биха ви помогнали за по-доброто решение на проблема.

## Бонуси

*   Нека подразбиращия се конструктор на DateTime да създава обект, съответстващ на текущия час. Използвайте функциите [time](http://en.cppreference.com/w/cpp/chrono/c/time) и [gmtime](http://en.cppreference.com/w/cpp/chrono/c/gmtime) от библиотеката [<ctime>](http://en.cppreference.com/w/cpp/chrono/c).
*   За всички конструктори и методи в условието по-горе се приема, че са им подадени валидни данни. Реализирайте проверка входните параметри чрез [assert](http://en.cppreference.com/w/cpp/error/assert) или чрез хвърляне на изключение при невалидни данни.
*   Реализирайте възможност за въвеждане/извеждане на `DateTime` обекти по зададен формат — например `"yyyy.MM.dd hh:mm:ss Z"`.
*   Разширете демострационната програма с подходящи функции.
