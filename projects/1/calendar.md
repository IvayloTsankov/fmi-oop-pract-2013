Нека да реализираме малка библиотека за работа с дати. Тя има следните класове:

Клас `TimeZone`, обектите на който отразяват отместване от определен брой часове спрямо часовата зона UTC. Реализирайте:

*   конструктор `TimeZone(name, offset)`. Името на часовата зона се състои от най-много 5 символа;
*   методи `getName` и `getOffset`;
*   оператори == и !=;
*   оператор `<<` за извеждане в поток — изведете името на часовата зона.

Добавете няколко константни статични члена към класа TimeZone, които да представят предварително дефинирани часови зони (по ваш избор кои). Например трябва с `TimeZone.UTC` да може да се достъпва обекта, представяш UTC часовата зона (с отместване 0), а с `TimeZone.EET` — източноевропейско време (с отместване +2).

Клас `Duration`, обектите на който представят продължителност от определен брой секунди. Той трябва да:

*   може да се конструира по `Duration(seconds, minutes, hours, days)`, `Duration(seconds, minutes, hours)`, `Duration(seconds, minutes)` и `Duration(seconds)` и `Duration()` (продължителност от нула секунди). Продължителността може да бъде и отрицателна;
*   има методи `asSeconds`, `asMinutes`, `asHours`, и `asDays`, връщащи продължителността в брой, съответно, секунди, минути, часове и дни закръглено надолу за неотрицателни стойности и нагоре за отрицателни. Например `Duration(3 * 60 * 60 + 4).asHours()` връща 3;
*   има методи `getSecond`, `getMinute` и `getHour` връщащи съответно секундата на текущата минута (между 0 и 59), минутата на текущия час (между 0 и 59), часът да текущия ден (между 0 и 23). Например `Duration(3 * 60 * 60 + 4).getSecond()` дава 4, а `Duration(3 * 60 * 60 + 4).getMinute() — 0;
*   предефинира оператори `+` и `-` за събиране и изваждане на продължителности;
*   предефинира операторите `<`, `<=`, `==`, `!=`, `>`, и `>=`;
*   предефинира оператор `<<` за извеждане в поток в подходящ формат по ваш избор. Например `3 hours and 4 seconds`.

Клас `DateTime`, представящ дата и час в определена часова зона.

Във всеки един момент за нашата програма има избрана часова зона по подразбиране. Тя трябва да може да се вземе чрез статичния метод `getDefaultTimeZone()` на DateTime и да може да бъде зададена чрез статичния метод `setDefaultTimeZone(timeZone)`. Нека първоначално тя да е UTC.

За `DateTime` реализирайте:

*   следните конструктори:
    -   `DateTime(year, month, day, hour, minute, second, timeZone)`;
    -   `DateTime(year, month, day, timeZone)`;
    -   `DateTime(year, month, day, hour, minute, second)`;
    -   `DateTime(year, month, day)`;
    -   `DateTime()` създаващ обект, съответващ на датата 1-ви януари 1970-та.
    
    Конструкторите, които не приемат часова зона, трябва да използват подразбиращата се;
    
*   селектори за всяко от `year`, `month`, `day`, `hour`, `minute`, `second` и `timeZone`;
*   метод `toTimeZone(timeZone)` връщащ нов обект с часа, конвертиран в съответната часова зона;
*   оператор `()`, приемащ часова зона, който връща същото като предишния метод;
*   оператори `+` и `-` с втори операнд — `Duration` обект;
*   оператор `-` с втори операнд `DateTime` обект, връщащ разликата между двете дати като продължителност (като тя трябва да е отрицателна, ако първата дата е преди втората);
*   релационните оператори `<`, `<=`, `==`, `!=`, `>`, и `>=`;
*   оператор `<<` за извеждане в поток в подходящ формат по ваш избор;

Всички методи и оператори трябва да могат да работят с часове от произволна часова зона.

Където е подходящо, се възползвайте от възможностите на `Duration` обектите (например за реализирането на релационните оператори).

Клас `Event`, обектите на който представят определено събитие. Събитието трябва да може да се конструира чрез следните конструктори:

*   `Event(name, startTime, endTime, priority, description)` и
*   `Event(name, startTime, duration, priority, description)`,

където `name` и `description` са низове с произволна дължина, а `priority` задава приоритета на събитието — нисък, нормален или висок.

Реализирайте селектори и мутатори за `name`, `startTime`, `endTime`, `duration`, `priority` и `description`. Събитията ще имат неотрицателна продължителност и крайната им дата няма да бъде преди началната.

Клас `Calendar`, представящ съвкупност от събития във времето. Освен това календарът си има и име — низ с произволна дължина. Съвкупността от събития може да реализирате по какъвто начин изберете, единствено изискване е да може да побере произволен брой събития.

Чрез конструктора `Calendar(name)` трябва да може да бъде създаван празен календар със съответното име.

За календара реализирайте още:

*   метод `getName`, връщащ името на календара;
*   оператор `<<` с ляв операнд календар и десен — събитие, добавящ събитието към календара;
*   в зависимост от реализация ви на множеството от събития, реализирайте подходящ интерфейс, който да позволява обхождане на всички събития в календара и тяхното премахване или промяна.

За всички класове:
*   където е необходимо дефинирайте собствени копиращ конструктор, оператор `=` и деструктор;
*   не забравяйте да декларирате методите, които трябва да бъдат константни, като такива. Ако за някои методи има смисъл да имат както константен така и неконстантен вариант, то реализирайте и двата.

Свободно може да добавяте и допълни класове, освен гореописаните, ако те биха ви помогнали за по-доброто решение на проблема.

Реализирайте програма, демонстрираща използването на горните класове, която да позволява на потребителя да:
*   създава нов календар и добавя събития в него;
*   да задава часова зона, в която да вижда събитията. Тя трябва да може да бъде променяна дори ако вече има въведени събития;
*   бъде изведен списък от всички събития. По желание на потребителя събитията трябва да могат да бъдат филтрирани по приоритет и/или интервал от начален и краен час.
*   записва събитията в текстов файл с определен формат. Аналогично, записаните събития трябва да могат да бъдат филтрирани по горните критерии. Часовете трябва да са в избраната от потребителя часова зона. Текстовият файл трябва да започва с името на календара, след което следват събитията, записани в избран от вас формат. Нека между всеки две събитията да има един празен ред.
