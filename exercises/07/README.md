# Упражнение 7

В това упражнение ще разширим класовете, които написахме в предното. Примерна тяхна реализация може да намерите в [директорията с решения на задачите от упражнение 6](../06/solution).

В това упражнение ще създаден вътрешен клас `Iterator` за нашия масив от рационални числа. Всеки итератор е обект, който сочи към определен елемент от дадена колекция, в случая от масива `RationalDynamicArray`. Итераторите предоставят удобен интерфейс, подобен на този на указателите, за обхождане на колекции.

Всеки итератор ще пази указател към масива, за който се отнася, и индекса на елемента, към който сочи. Освен към същестуващите елементи, итераторите могат да сочат и към един елемент след края на масива, като тогава стойността на index е равна на стойността на size на масива.

Реализирайте вътрешен за `RationalDynamicArray` клас `Iterator`, който:
* има описаните полета;
* има `private` конструктор `Iterator(RationalDynamicArray& arr, int index)`, който инициализира полетата чрез инициализиращ списък. Това, че конструкторът е private позволява само ограничен набор от обекти, наречени приятели на класа `Iterator`, да могат да създават негови инстанции;
* дефинирайте публичен конструктор по подразбиране, който инициализира указателя към динамичния масив с `NULL`. Описаните по-долу операции се очаква да работят само за създадените с горния конструктор итератори. (Този конструктор съществува само защото се изисква от C++ за двупосочните итератори (виж по-долу).)
* декларирайте класа `RationalDynamicArray` като приятел на `Iterator`;
* реализирайте унарни оператор `*` и `->`, които съответно връщат псевдоним и указател към сочения елемент на масива;
* реализирайте оператори `==` и `!=`, които връщат дали указателите сочат към един и същи елемент;
* реализирайте префиксни и постфиксни оператор `++` и `--`, които насочват итератора към съответно следващия или предишния елемент на масива и спазват семантиката за това да връщат обекта-итератор или предишната стойност на итератор, в зависимост от това дали имаме префиксен или постфиксен оператор.

Добавете следните методи към класа `RationalDynamicArray`:
* метод `Iterator begin()` връщаш итератор към последния елемент на масива;
* метод `Iterator end()` връщаш итератор към елемента след последния на масива (съответващ на size).

Допълнително дефинирайте статичен метод `int getNumberOfInstances()` за класа `Iterator`, който да казва колко инстанции на обекта итератор съществуват в момента. Дефинирайте необходимите ви статични променливи и променете конструктора и деструктора на `Iterator` по подходящ начин.

Итераторите може да бъдат използвани по следния начин:

    typedef RationalDynamicArray::Iterator RatIt;
    
    for (RatIt i = arr.begin(), i != arr.end(), ++i) {
        i->print();
    }

където `arr` е масив от тип `RationalDynamicArray`.

## Допълнителна информация

По този начин реализирахме [изискванията за двупосочен итератор на C++](http://www.cplusplus.com/reference/iterator/BidirectionalIterator/). Това ни позволява да използваме нашия масив със всички функции от библиотеката [<algorithm>](http://www.cplusplus.com/reference/algorithm/). 

(Забележка: Във Visual Studio е възможно да е необходимо допълно да бъде включена библиотеката `<iterator>` и декларацията на класа `Iterator` да има следния вид:

    class Iterator : public std::iterator<std::bidirectional_iterator_tag, Rational> {
    };

По принцип това не би трябвало да е задължително.)

Например намирането на максималния елемент на масива може да стане по следния начин:

    max_element(arr.begin(), arr.end());
    
Принтиране на всички елементи:

    void printRational(const Rational& rat) {
        cout << rat << endl;
    }
    
    for_each(arr.begin(), arr.end(), printRational);

Обръщане на елементи на масив:

    Rational inverseRational(const Rational& rat) {
        return ~rat;
    }

    transform(arr.begin(), arr.end(), arr.begin(), inverseRational);

или, по-кратко:

    transform(arr.begin(), arr.end(), arr.begin(), mem_fun_ref(&Rational::inverse));

където `mem_fun_ref` е функция от библиотеката `<functional>`, връщаща версия на `inverse`, която може да бъде извикнвана с рационално число, върху което да бъде приложена функцията (връща функция, която е почти като inverseRational горе).

Итераторите позволяват на нашия масив да бъде използван и с въведения в C++11 range-based for statement за цикъл. Синтаксисът е следният:

    RationalDynamicArray arr;
    
    ...
    
    for (Rational& rat : arr) {
        cout << ~rat << endl;
    }

Изпробвайте горните примери.

В нашия случай на реализация — с динамично-заделен масив — методите `begin` и `end` биха могли да връщат указател към съответно първия елемент на масива и елемента след последния, вместо да връщат итератора, който реализирахме по-горе. Указателите могат да работят с всички оператори, които се изискват от един итератор, и затова те могат да играят ролята на итератор. Единствената разлика би била в това кога итераторите стават невалидни — обектите на итератора, който реализирахме по-горе, продължават да сочат към рационално число дори след като се случи преоразмеряване на масива (стига да има елемент на съответния индекс), а в същия този случай указателите не биха сочили към валидна стойност.
