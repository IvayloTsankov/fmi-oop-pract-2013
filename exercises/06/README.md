# Упражнение 6 — предефиниране на оператори

В това упражнение ще разширим класовете, които написахме в предното. Примерна тяхна реализация може да намерите на [https://github.com/zstoychev/fmi-oop-pract-2013/tree/master/exercises/05/solution](https://github.com/zstoychev/fmi-oop-pract-2013/tree/master/exercises/05/solution).

## Задача 1

Предефинирайте следните оператори за класа `Rational`:

* аритметичните оператори `+`, `-`, `*`, `/` и съответстващите им `+=`, `-=`, `*=` и `/=` приемащи рационално число. В примерната реализация числата се съхраняват в съкратен вид. Предефинирайки операторите, запазете тази реализация;
* същите аритметични оператори, приемащи цяло число;
* унарният аритметичен оператор `-`, връщаш противоположното рационално число;
* релационните оператори `<`, `<=`, `==`, `!=`, `>` и `>=`. Реализирайте ги по подходящ начин един спрямо друг;
* оператори за преобразуване към `int` (с закръгляне надолу), `float`, `double` и `bool`. Преобразуването към `bool` връща дали рационалното число е различно от 0;
* оператор `^`, повдигащ числото на цяла степен;
* оператор `~`, връщаш реципрочното на числото;
* оператор `<<` за извеждане на числото в поток.

## Задача 2

Предефинирайте следните оператори за класа `RationalDynamicArray`:

* оператор `[]`, връщаш елемент на индекс. Реализирайте както константна, така и неконстантна форма;
* оператор `<<`, която добавя рационално число в края на масива;
* оператор `>>`, която премахва последния елемент на масива и го записва в подаден по псевдоним обект от тип рационално число;
* оператор `<<`, който добавя всички елементи на друг динамичен масив в текущия масив;
* оператор за преобразуване към `bool`, връщащ дали масивът има елементи;
* (*) оператор `()`, който приема указател към функция, приемаща и връщаща рационално число, който прилага функцията върху всички елементи на масива и ги заменя с резултата от нея.

Реализирайте `explicit` конструктор, който позволява масивът да бъде създаден по подаден начален капацитет.
